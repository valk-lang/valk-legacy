
use io
use os

fn gc() {
    gc_local.gc()
}
fn force_gc() {
    gc_local.force_full = true
    gc_local.gc()
}

fn update_usage() {
    // Calculate mem usage
    if mem_new > mem_trigger : gc()
    // mem_usage = mem_new * 100 / mem_trigger
    // if mem_usage > 20 {
    //     gc()
    // }
}

fn gc_mark[T](item: T, color: u16) {

    let item_ptr = item @as ptr
    let item_color = @ptrv(item_ptr, u16, byte_color_rel)
    if @ptrv(colors.state, u8, item_color) == color_state_used { 
        return
    }

    @ptrv(item_ptr, u16, byte_color_rel) = color

    if item_color == 0 {
        let size : uint = sizeof(inline T) + 8
        mem_marked += size

        let block_index = @ptrv(item_ptr, u8, byte_block_index_rel) & 127
        let block_start = item_ptr - 8 - block_index * size
        @ptrv(block_start, uint, -2)++ // Increase used items count
    }

    let added = false
    #loop_object_properties item as prop, type
    #if @type_is_gc(type)
    {
        let p = prop
        #if @type_is_nullable(type)
        if isset(p) {
        #end
            gc_mark[type](p, color)
            // Check if linked to another color
            if !added {
                let prop_ptr = p @as ptr
                let prop_color = @ptrv(prop_ptr, u16, byte_color_rel)
                if prop_color != color {
                    remark.add(p @as ptr)
                    added = true
                }
            }
        #if @type_is_nullable(type)
        }
        #end
    }
    #end
    #endloop
}

fn gc_demark[T](item: T, color: u16) {

    let item_ptr = item @as ptr
    
    if @ptrv(item_ptr, u16, byte_color_rel) != color : return
    @ptrv(item_ptr, u16, byte_color_rel) = color_blank

    let size : uint = sizeof(inline T) + 8
    mem_marked -= size

    let block_index = @ptrv(item_ptr, u8, byte_block_index_rel) & 127
    let block_start = item_ptr - 8 - block_index * size
    @ptrv(block_start, uint, -2)-- // Increase used items count

    #loop_object_properties item as prop, type
    #if @type_is_gc(type)
    {
        let p = prop
        #if @type_is_nullable(type)
        if isset(p) {
        #end
            gc_demark[type](p, color)
        #if @type_is_nullable(type)
        }
        #end
    }
    #end
    #endloop

    // let propc = @ptrv(item, u8, byte_gc_prop_count_rel)
    // if propc > 0 {
    //     let i = 0
    //     let has_vtable = @ptrv(item, bool, byte_has_vtable_rel)
    //     if has_vtable : i++
    //     while propc-- > 0 {
    //         let sub = @ptrv(item, ptr, i++)
    //         if sub == null : continue
    //         gc_demark(sub, color)
    //     }
    // }
}

fn gc_mark_shared(item: ptr, age: u8) {

    if @ptrv(item, u16, byte_color_rel) > state_const : return
    if @ptrv(item, u8, byte_shared_age_rel) == age : return
    @ptrv(item, u8, byte_shared_age_rel) = age

    // let propc = @ptrv(item, u8, byte_gc_prop_count_rel)
    // if propc > 0 {
    //     let has_vtable = @ptrv(item, bool, byte_has_vtable_rel)
    //     let i = 0
    //     if has_vtable {
    //         i++
    //         // Hook
    //         let vtable = @ptrv(item, ptr, 0)
    //         let hook = @ptrv(vtable, ?fn(ptr, u8)(), vt_hook_mark_shared)
    //         if isset(hook) : hook(item, age)
    //     }
    //     while propc-- > 0 {
    //         let sub = @ptrv(item, ptr, i++)
    //         if sub == null : continue
    //         gc_mark_shared(sub, age)
    //     }
    // }
}

fn gc_share(item: ptr) {

    if @ptrv(item, u8, byte_state_rel) > state_solid : return

    let state = @ptrv(item, u8, byte_state_rel)
    if state < state_solid {
        let pool_index = @ptrv(item, u8, byte_pool_index)
        let pool = @ptrv(pools, GcPool, pool_index)
        let size = pool.isize

        mem_transfered += size

        let block_index = @ptrv(item, u8, byte_block_index_rel) & 127
        let block_start = item - 8 - block_index * size
        @ptrv(block_start, uint, -2)++ // Increase used items count
    }

    @ptrv(item, u8, byte_state_rel) = state_shared
    @ptrv(item, u8, byte_shared_age_rel) = shared_age
    stack.add_shared(item)

    let propc = @ptrv(item, u8, byte_gc_prop_count_rel)
    if propc > 0 {
        let has_vtable = @ptrv(item, bool, byte_has_vtable_rel)
        let i = 0
        if has_vtable {
            i++
            // Hook
            let vtable = @ptrv(item, ptr, 0)
            let hook = @ptrv(vtable, ?fn(ptr)(), vt_hook_share)
            if isset(hook) : hook(item)
        }
        while propc-- > 0 {
            let sub = @ptrv(item, ptr, i++)
            if sub == null : return
            gc_share(sub)
        }
    }
}

fn reset_allocators() {
    let alcs = gc_item_allocators
    let count = gc_item_allocator_count
    let i : uint = 0
    while i < count {
        let alc = @ptrv(alcs, ptr, i++)
        let reset = @ptrv(alcs, fn(ptr)(), i++)
        reset(alc)
    }
}