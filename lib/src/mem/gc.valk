
use io
use os

fn gc_bump_alloc(size: uint) ptr {
    return stack.bump.alloc(size)
}
fn gc() {
    stack.gc()
}
fn force_gc() {
    stack.force_full = true
    stack.gc()
}

fn update_usage() {
    // 
    let pos = stack_pos
    let diff : uint = (pos.adr - pos.base) @as uint
    //
    if mem_min <= diff : 
        diff -= mem_min

    // Calculate mem usage
    mem_usage = mem_new * 100 / mem_marked
    // Scale mem_usage trigger point based on stack position
    let cap : uint = 15 * (diff * 20 / mem_max + 1)

    if mem_usage > cap {
        // if diff <= mem_trigger {
            gc()
            // mem_trigger = diff
        // } else {
        //     mem_trigger = (mem_trigger + diff) / 2
        // }
        mem_gc_loop = false
    } else {
        mem_gc_loop = mem_usage > 15
        // if max > 128 {
        //     mem_max -= sizeof(ptr)
        // }
    }

    // Update min/max
    mem_min += sizeof(ptr)
    if mem_max > 128 :
    mem_max -= sizeof(ptr)
    // mem_min = (mem_min * 9 + mem_max) / 10
    // mem_max = (mem_max * 9 + mem_min) / 10
}

fn gc_transfer(item: ptr) {

    if @ptrv(item, u8, byte_state_rel) > state_transfer : return
    @ptrv(item, u8, byte_state_rel) = state_solid

    let pool_index = @ptrv(item, u8, byte_pool_index_rel)
    let pool = @ptrv(pools, GcPool, pool_index)
    let size = pool.isize

    mem_transfered += size

    let block_index = @ptrv(item, u8, byte_block_index_rel)
    let block_start = item - 8 - block_index * size
    @ptrv(block_start, uint, -2)++ // Increase used items count

    let propc = @ptrv(item, u8, byte_gc_prop_count_rel)
    if propc > 0 {
        let has_vtable = @ptrv(item, bool, byte_has_vtable_rel)
        let i = 0
        if has_vtable {
            i++
            // Hook
            let vtable = @ptrv(item, ptr, 0)
            let hook = @ptrv(vtable, ?fn(ptr)(), vt_hook_transfer)
            if isset(hook) : hook(item)
        }
        while propc-- > 0 {
            let sub = @ptrv(item, ptr, i++)
            if sub == null : continue
            gc_transfer(sub)
        }
    }
}

fn gc_mark(item: ptr, age: u8) {

    if @ptrv(item, u8, byte_state_rel) > state_const : return
    if @ptrv(item, u8, byte_age_rel) == age : return
    @ptrv(item, u8, byte_age_rel) = age

    let pool_index = @ptrv(item, u8, byte_pool_index_rel)
    let pool = @ptrv(pools, GcPool, pool_index)
    let size = pool.isize

    mem_marked += size

    let propc = @ptrv(item, u8, byte_gc_prop_count_rel)
    if propc > 0 {
        let has_vtable = @ptrv(item, bool, byte_has_vtable_rel)
        let i = 0
        if has_vtable {
            i++
            // Hook
            let vtable = @ptrv(item, ptr, 0)
            let hook = @ptrv(vtable, ?fn(ptr, u8)(), vt_hook_mark)
            if isset(hook) : hook(item, age)
        }
        while propc-- > 0 {
            let sub = @ptrv(item, ptr, i++)
            if sub == null : continue
            gc_mark(sub, age)
        }
    }
}

fn gc_mark_shared(item: ptr, age: u8) {

    if @ptrv(item, u8, byte_state_rel) > state_const : return
    if @ptrv(item, u8, byte_shared_age_rel) == age : return
    @ptrv(item, u8, byte_shared_age_rel) = age

    let propc = @ptrv(item, u8, byte_gc_prop_count_rel)
    if propc > 0 {
        let has_vtable = @ptrv(item, bool, byte_has_vtable_rel)
        let i = 0
        if has_vtable {
            i++
            // Hook
            let vtable = @ptrv(item, ptr, 0)
            let hook = @ptrv(vtable, ?fn(ptr, u8)(), vt_hook_mark_shared)
            if isset(hook) : hook(item, age)
        }
        while propc-- > 0 {
            let sub = @ptrv(item, ptr, i++)
            if sub == null : continue
            gc_mark_shared(sub, age)
        }
    }
}

fn gc_share(item: ptr) {

    if @ptrv(item, u8, byte_state_rel) > state_solid : return

    let state = @ptrv(item, u8, byte_state_rel)
    if state < state_solid {
        let pool_index = @ptrv(item, u8, byte_pool_index)
        let pool = @ptrv(pools, GcPool, pool_index)
        let size = pool.isize

        mem_transfered += size

        let block_index = @ptrv(item, u8, byte_block_index_rel)
        let block_start = item - 8 - block_index * size
        @ptrv(block_start, uint, -2)++ // Increase used items count
    }

    @ptrv(item, u8, byte_state_rel) = state_shared
    @ptrv(item, u8, byte_shared_age_rel) = shared_age
    stack.add_shared(item)

    let propc = @ptrv(item, u8, byte_gc_prop_count_rel)
    if propc > 0 {
        let has_vtable = @ptrv(item, bool, byte_has_vtable_rel)
        let i = 0
        if has_vtable {
            i++
            // Hook
            let vtable = @ptrv(item, ptr, 0)
            let hook = @ptrv(vtable, ?fn(ptr)(), vt_hook_share)
            if isset(hook) : hook(item)
        }
        while propc-- > 0 {
            let sub = @ptrv(item, ptr, i++)
            if sub == null : return
            gc_share(sub)
        }
    }
}

fn pools_swap_transfers() {
    let alcs = pools
    let count = pool_count
    let i : uint = 0
    while i < count {
        let pool = @ptrv(alcs, GcPool, i++)
        pool.swap_transfers()
    }
}

fn pools_clean_unmarked(age: u8) {
    let alcs = pools
    let count = pool_count
    let i : uint = 0
    while i < count {
        let pool = @ptrv(alcs, GcPool, i++)
        pool.clean_unmarked(age)
    }
    gc_alloc_clean_unmarked(age)
}

fn pools_reset() {
    let alcs = pools
    let count = pool_count
    let i : uint = 0
    while i < count {
        let pool = @ptrv(alcs, GcPool, i++)
        pool.reset()
    }
    gc_alloc_reset()
}
