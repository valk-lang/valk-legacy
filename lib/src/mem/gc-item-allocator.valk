

global gc_item_allocators: ptr (@undefined)
global gc_item_allocator_count: u32
global gc_item_allocator_size: u32
global gc_reset_functions: ptr (@undefined)

global gc_vtable: Bump (@undefined)
global gc_vtable_data: ptr (@undefined)

value GC_VTABLE_SIZE (3)
value GC_VTABLE_MARK (0)
value GC_VTABLE_DEMARK (1)
value GC_VTABLE_HOOK_FREE (2)

value POOL_DATA_OFFSET (sizeof(ptr) * 4)

cstruct GcItemAllocator[T] {
    allocator_index: u32
    //
    blockc: uint (1)
    first: ptr (null @as ptr)
    block: ptr (null @as ptr)
    index: uint (0)
    isize: uint

    static fn init() SELF {
        let index = gc_item_allocator_count++
        if index == 0 {
            gc_item_allocator_count++
            index = 1
        }
        let alc = SELF {
            isize: sizeof(inline T) + 8
            allocator_index: index
        }

        // 
        if index >= gc_item_allocator_size {
            let size = gc_item_allocator_size
            if size == 0 {
                size = 100
                gc_item_allocators = alloc(sizeof(ptr) * size)
                gc_reset_functions = alloc(sizeof(ptr) * size)
            } else {
                let bytes = size * sizeof(ptr)
                gc_item_allocators = resized_clone_and_free(gc_item_allocators, bytes, bytes * 2)
                gc_reset_functions = resized_clone_and_free(gc_reset_functions, bytes, bytes * 2)
            }
            gc_item_allocator_size = size
        }

        @ptrv(gc_item_allocators, SELF, index) = alc
        @ptrv(gc_reset_functions, ptr, index) = alc.reset @as ptr

        let vtable = gc_vtable
        vtable.minimum_size((index + 1) * GC_VTABLE_SIZE * sizeof(ptr))
        gc_vtable_data = vtable.data

        let vt = @ptr_offset(vtable.data, index * GC_VTABLE_SIZE * sizeof(ptr))
        @ptrv(vt, ptr, GC_VTABLE_MARK) = gc_mark[T] @as ptr
        @ptrv(vt, ptr, GC_VTABLE_DEMARK) = gc_demark[T] @as ptr
        @ptrv(vt, ptr, GC_VTABLE_HOOK_FREE) = null @as ptr

        return alc
    }

    static fn create_block(size: uint, isize: uint, alc_index: u32) ptr {
        if size > 124 : size = 124
        let b = alloc(size * isize + POOL_DATA_OFFSET)
        // Settings
        @ptrv(b, ?ptr, 0) = null // next block
        @ptrv(b, uint, 1) = size // count
        @ptrv(b, uint, 2) = 0 // used
        @ptrv(b, uint, 3) = 0 // usage percent
        // Set indexes
        let data = b + POOL_DATA_OFFSET
        let i : u8 = 0
        while i < size {
            let item : ptr = data + i * isize
            @ptrv(item, u16, byte_color) = color_blank
            @ptrv(item, u8, byte_shared_age) = 0
            @ptrv(item, u8, byte_block_index) = i
            @ptrv(item, u32, 1) = alc_index
            i++
        }

        return b
    }

    fn get() ptr {

        let isize = this.isize
        if this.block == null {
            this.block = SELF.create_block(this.blockc * 2, isize, this.allocator_index)
            this.first = this.block
        }

        while true {
            let block = this.block
            if @ptrv(block, uint, 3) > 90 {
                this.set_next_block(block)
                continue
            }
            let index = this.index
            if index == @ptrv(block, uint, 1) {
                this.set_next_block(block)
                continue
            }
            this.index++
            let data = block + POOL_DATA_OFFSET
            let item = data + index * isize
            if @ptrv(item, u16, byte_color) != color_blank {
                continue
            }

            // Increase mem usage
            mem_new += isize

            return (item + 8)
        }
        print("Failed to allocate memory")
        print("\n")
        exit(1)
    }

    fn set_next_block(block: ptr) {
        let next = @ptrv(block, ?ptr, 0)
        if isset(next) {
            this.set_block(next)
        } else {
            // Create new block
            let blockc = ++this.blockc
            let new = SELF.create_block(blockc * blockc, this.isize, this.allocator_index)
            // Set next
            @ptrv(block, ptr, 0) = new
            this.set_block(new)
        }

        // Check mem usage
        update_usage()
    }

    fn set_block(block: ptr) {
        this.block = block
        this.index = 0
    }

    fn reset() {
        let block = this.first
        if block == null : return

        let current = this.block

        let reached_current = false
        let last : ?ptr = null
        let first_empty_block : ?ptr = null
        let last_empty_block : ?ptr = null

        let t : uint = 0

        while block != null {
            let b = block
            let used = @ptrv(b, uint, 2)
            let next = @ptrv(b, ptr, 0)
            @ptrv(b, ?ptr, 0) = null // clear next
            t += @ptrv(b, uint, 1)
            //
            if used == 0 {
                if reached_current == false {
                    @ptrv(b, uint, 3) = 0
                    if isset(last_empty_block) {
                        @ptrv(last_empty_block, ptr, 0) = b
                        last_empty_block = b
                    } else {
                        first_empty_block = b
                        last_empty_block = b
                    }
                } else {
                    free(b)
                    this.blockc--
                }
            } else {
                // Update usage percent
                let count = @ptrv(b, uint, 1)
                @ptrv(b, uint, 3) = used * 100 / count
                //
                if isset(last) : @ptrv(last, ptr, 0) = b
                else : this.first = b
                last = b
            }
            if b == current : reached_current = true
            block = next
        }

        if isset(first_empty_block) {
            if isset(last)  {
                @ptrv(last, ptr, 0) = first_empty_block
            } else {
                this.first = first_empty_block
            }
        } else {
            if isset(last)  {
                @ptrv(last, ?ptr, 0) = null
            }
        }

        this.set_block(this.first)
    }

}
