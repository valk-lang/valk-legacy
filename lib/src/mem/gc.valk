
use io
use os

fn gc_bump_alloc(size: uint) ptr {
    return stack.bump.alloc(size)
}
fn gc() {
    stack.gc()
}
fn force_gc() {
    stack.force_full = true
    stack.gc()
}

fn update_usage() {
    // 
    let pos = stack_pos
    let diff : uint = (pos.adr - pos.base) @as uint
    //
    if mem_min <= diff : 
        diff -= mem_min

    // Calculate mem usage
    mem_usage = mem_new * 100 / mem_marked
    // Scale mem_usage trigger point based on stack position
    let cap : uint = 5 * (diff * 30 / mem_max + 1)

    if mem_usage > cap {
        // if diff <= mem_trigger {
            gc()
            // mem_trigger = diff
        // } else {
        //     mem_trigger = (mem_trigger + diff) / 2
        // }
        mem_gc_loop = false
    } else {
        // mem_gc_loop = mem_usage > 15
        // if max > 128 {
        //     mem_max -= sizeof(ptr)
        // }
    }

    // Update min/max
    mem_min += sizeof(ptr)
    if mem_max > 128 :
    mem_max -= sizeof(ptr)
    // mem_min = (mem_min * 9 + mem_max) / 10
    // mem_max = (mem_max * 9 + mem_min) / 10
}

fn gc_transfer(item: ptr) {

    if @ptrv(item, u8, byte_state_rel) > state_transfer : return
    @ptrv(item, u8, byte_state_rel) = state_solid

    let pool_index = @ptrv(item, u8, byte_pool_index_rel)
    let pool = @ptrv(pools, GcPool, pool_index)
    let size = pool.isize

    mem_transfered += size

    let block_index = @ptrv(item, u8, byte_block_index_rel)
    let block_start = item - 8 - block_index * size
    @ptrv(block_start, uint, -2)++ // Increase used items count

    // Hook
    let vtable = @ptrv(item, ptr, 0)
    let hook = @ptrv(vtable, ?fn(ptr)(), vt_hook_transfer)
    if isset(hook) : hook(item)

    let propc = @ptrv(item, u8, byte_gc_prop_count_rel) + 2
    while propc-- > 2 {
        let sub = @ptrv(item, ptr, propc)
        if sub == null : continue
        @ptrv(sub, uint, 1)++
        gc_transfer(sub)
    }
}

fn gc_free(item: ptr) {
    print("_F_")
    if @ptrv(item, u8, byte_state_rel) != state_solid : return
    @ptrv(item, u8, byte_state_rel) = state_new
    @ptrv(item, u8, byte_age_rel) = 0
    @ptrv(item, u8, byte_shared_age_rel) = 0

    // Hook
    let vtable = @ptrv(item, ptr, 0)
    let hook = @ptrv(vtable, ?fn(ptr)(), vt_hook_free)
    if isset(hook) : hook(item)

    let propc = @ptrv(item, u8, byte_gc_prop_count_rel) + 2
    while propc-- > 2 {
        let sub = @ptrv(item, ptr, propc)
        if sub == null : continue
        let rc = @ptrv(sub, uint, 1)
        @ptrv(sub, uint, 1) = rc - 1
        if rc == 1 {
            gc_free(sub)
        }
    }
}

fn gc_mark(item: ptr, age: u8) {

    if @ptrv(item, u8, byte_state_rel) > state_const : return
    if @ptrv(item, u8, byte_age_rel) == age : return
    @ptrv(item, u8, byte_age_rel) = age

    let pool_index = @ptrv(item, u8, byte_pool_index_rel)
    let pool = @ptrv(pools, GcPool, pool_index)
    let size = pool.isize

    mem_marked += size

    // Hook
    let vtable = @ptrv(item, ptr, 0)
    let hook = @ptrv(vtable, ?fn(ptr)(), vt_hook_mark)
    if isset(hook) : hook(item)

    let propc = @ptrv(item, u8, byte_gc_prop_count_rel) + 2
    while propc-- > 2 {
        let sub = @ptrv(item, ptr, propc)
        if sub == null : continue
        gc_mark(sub, age)
    }
}

fn gc_mark_shared(item: ptr, age: u8) {

    if @ptrv(item, u8, byte_state_rel) > state_const : return
    if @ptrv(item, u8, byte_shared_age_rel) == age : return
    @ptrv(item, u8, byte_shared_age_rel) = age

    // Hook
    let vtable = @ptrv(item, ptr, 0)
    let hook = @ptrv(vtable, ?fn(ptr)(), vt_hook_mark_shared)
    if isset(hook) : hook(item)

    let propc = @ptrv(item, u8, byte_gc_prop_count_rel) + 2
    while propc-- > 2 {
        let sub = @ptrv(item, ptr, propc)
        if sub == null : continue
        gc_mark_shared(sub, age)
    }
}

fn gc_share(item: ptr) {

    if @ptrv(item, u8, byte_state_rel) > state_solid : return

    let state = @ptrv(item, u8, byte_state_rel)
    if state < state_solid {
        let pool_index = @ptrv(item, u8, byte_pool_index)
        let pool = @ptrv(pools, GcPool, pool_index)
        let size = pool.isize

        mem_transfered += size

        let block_index = @ptrv(item, u8, byte_block_index_rel)
        let block_start = item - 8 - block_index * size
        @ptrv(block_start, uint, -2)++ // Increase used items count
    }

    @ptrv(item, u8, byte_state_rel) = state_shared
    @ptrv(item, u8, byte_shared_age_rel) = shared_age
    stack.add_shared(item)

    // Hook
    let vtable = @ptrv(item, ptr, 0)
    let hook = @ptrv(vtable, ?fn(ptr)(), vt_hook_share)
    if isset(hook) : hook(item)

    let propc = @ptrv(item, u8, byte_gc_prop_count_rel) + 2
    while propc-- > 2 {
        let sub = @ptrv(item, ptr, propc)
        if sub == null : continue
        gc_share(sub)
    }
}

fn pools_swap_transfers() {
    let alcs = pools
    let count = pool_count
    let i : uint = 0
    while i < count {
        let pool = @ptrv(alcs, GcPool, i++)
        pool.swap_transfers()
    }
}

fn pools_clean_unmarked(age: u8) {
    let alcs = pools
    let count = pool_count
    let i : uint = 0
    while i < count {
        let pool = @ptrv(alcs, GcPool, i++)
        pool.clean_unmarked(age)
    }
    gc_alloc_clean_unmarked(age)
}

fn pools_reset() {
    let alcs = pools
    let count = pool_count
    let i : uint = 0
    while i < count {
        let pool = @ptrv(alcs, GcPool, i++)
        pool.reset()
    }
    gc_alloc_reset()
}
