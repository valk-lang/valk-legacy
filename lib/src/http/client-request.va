
header "openssl" as ssl

use net
use type
use url
use utils

struct ClientResponse {
    status: uint (0)
    headers: Map[String] (map[String]{})
    body: String ("")
}

struct ClientRequest {
    method: String
    url: String
    body: String ("")
    headers: Map[String] (map[String]{})

    fn exec() ClientResponse !invalid_url !connection_failed !invalid_response {

        let parts = url:parse(this.url)

        let is_https = parts.scheme == "https"

        let split = parts.host.split(":")
        let host = parts.host
        let port = is_https ? 443 @as u16 : 80 @as u16
        if split.length > 2 : throw invalid_url
        if split.length == 2 {
            host = split.get(0) ? ""
            let p = split.get(1) ! throw invalid_url
            port = (p.to_uint() ! throw invalid_url) @as u16
        }

        let sock = net:Socket.new_tcp(host, port) ! {
            throw invalid_url, "Invalid request url"
        }

        let con = sock.connect() ! {
            throw connection_failed, "Connection failed"
        }

        if is_https {
            con.ssl_connect() ! {
                con.close()
                throw connection_failed, "SSL connection failed"
            }
        }

        // Send request
        let buf = this.get_send_data(parts)
        con.send_byte_buffer(buf) ! {
            con.close()
            throw connection_failed, "Unexpected non-blocking connection"
        }

        //
        let parser = RequestParser{}
        let request = Request{}
        let rbytes : uint = 8192
        let buffer = parser.input
        while true {
            parser.parse(request, true) err ! {
                // Check if we need more data
                if error_is(err, !incomplete) {
                    let bytes = con.recv(buffer, rbytes) err ! {
                        con.close()
                        throw invalid_response
                    }
                    if bytes == 0 : throw invalid_response
                    continue
                }
                con.close()
                throw invalid_response
            }
            if parser.parsed_body : break
        }

        return ClientResponse {
            status: request.status
            headers: request.headers()
            body: request.body
        }
    }

    - fn get_send_data(parts: url:Url) utils:ByteBuffer {

        let len = this.body.bytes
        let buf = utils:ByteBuffer.new(len + 256)

        let method = this.method

        buf.append_str(method)
        buf.append_str(" ")
        buf.append_str(parts.path)
        if parts.query != "" {
            buf.append_str("?")
            buf.append_str(parts.query)
        }
        buf.append_str(" HTTP/1.1\r\n")

        buf.append_str("Host: ")
        buf.append_str(parts.host)
        buf.append_str("\r\n")

        buf.append_str("Content-Length: ")
        buf.append_str(this.body.bytes)
        buf.append_str("\r\n")

        let headers = this.headers
        each headers._keys as i,k {
            let v = headers._values.get(i) ! break
            buf.append_str(k)
            buf.append_str(": ")
            buf.append_str(v)
            buf.append_str("\r\n")
        }

        buf.append_str("\r\n")
        buf.append_str(this.body)

        return buf
    }
}
