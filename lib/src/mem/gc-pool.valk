
use io

value GP_DATA_OFFSET (sizeof(ptr) * 4)

global pools: @ignu(ptr)
global pool_count: uint

fn init_pools() {
    let list = alloc(150 * sizeof(ptr))
    pools = list
    let isize : uint = sizeof(ptr)
    let i : u8 = 0
    // 16 - 128
    while isize < 128 {
        isize += sizeof(ptr)
        @ptrv(list, ptr, i) = GcPool.init(isize, false, i)
        i++
        @ptrv(list, ptr, i) = GcPool.init(isize, true, i)
        i++
    }
    // 256 - max
    let pow : uint = 7
    let maxbits : uint = sizeof(ptr) * 8 - 24
    while pow < maxbits {
        let isize : uint = 2 << pow++
        @ptrv(list, ptr, i) = GcPool.init(isize, false, i)
        i++
        @ptrv(list, ptr, i) = GcPool.init(isize, true, i)
        i++
    }

    pool_count = i
    pools = list
}

cstruct GcPool {
    blockc: uint
    first: ptr
    block: ptr
    index: uint (0)
    isize: uint (0)
    pool_index: u8
    has_free_hook: bool
    // count_new: bool (false)

    static fn init(size: uint, has_free_hook: bool, pool_index: u8) SELF {
        let isize = size + 8
        let blockc : uint = 1
        let block = null @as ptr
        let res = SELF{
            blockc: blockc
            first: block
            block: block
            isize: isize
            pool_index: pool_index
            has_free_hook: has_free_hook
        }
        return res
    }

    static fn create_block(size: uint, isize: uint, pool_index: u8) ptr {
        if size > 248 : size = 248
        let b = alloc(size * isize + GP_DATA_OFFSET)
        // Settings
        @ptrv(b, ?ptr, 0) = null // next block
        @ptrv(b, uint, 1) = size // count
        @ptrv(b, uint, 2) = 0 // used
        @ptrv(b, uint, 3) = 0 // usage percent
        // Set indexes
        let data = b + GP_DATA_OFFSET
        let i : u8 = 0
        while i < size {
            let item : ptr = data + i * isize
            @ptrv(item, u64, 0) = 0 // clear data
            @ptrv(item, u8, 0) = state_new
            @ptrv(item, u8, 1) = 0
            @ptrv(item, u8, 2) = 0
            @ptrv(item, u8, 3) = pool_index
            @ptrv(item, u8, 4) = i
            i++
        }
        return b
    }

    fn get() ptr {

        let isize = this.isize
        if this.block == null {
            this.block = SELF.create_block(this.blockc * 2, isize, this.pool_index)
            this.first = this.block
            // this.count_new = true
        }

        while true {
            let block = this.block
            if @ptrv(block, uint, 3) > 90 {
                this.set_next_block(block)
                continue
            }
            let index = this.index
            if index == @ptrv(block, uint, 1) {
                this.set_next_block(block)
                continue
            }
            this.index++
            let data = block + GP_DATA_OFFSET
            let item = data + index * isize
            if @ptrv(item, u16, byte_color) != state_new {
                continue
            }

            // if this.has_free_hook {
            //     @ptrv(item, u8, byte_state) = state_used
            // }

            // Increase mem usage
            // if this.count_new : mem_new += isize
            mem_new += isize

            return (item + 8)
        }
        print("Failed to allocate memory")
        print("\n")
        exit(1)
    }

    fn set_next_block(block: ptr) {
        let next = @ptrv(block, ?ptr, 0)
        if isset(next) {
            this.set_block(next)
        } else {
            // Create new block
            let blockc = ++this.blockc
            let new = SELF.create_block(blockc * blockc, this.isize, this.pool_index)
            // Set next
            @ptrv(block, ptr, 0) = new
            this.set_block(new)
        }

        // if(@ptrv(this.block, ptr, 2) == 0) {
        //     this.count_new = true
        // }

        // Check mem usage
        update_usage()
    }

    fn set_block(block: ptr) {
        this.block = block
        this.index = 0
    }

    fn swap_transfers() {
        if !this.has_free_hook : return
        return
        //
        let current = this.block
        let block = this.first
        let isize = this.isize
        if block == null : return

        while block != current {
            let b = block
            let count = @ptrv(b, uint, 1)
            // Loop items
            let i : uint = 0
            let data = b + GP_DATA_OFFSET
            while i < count {
                let item = data + i * isize
                if @ptrv(item, u8, byte_state) == state_used {
                    let ob = item + 8
                    let vtable = @ptrv(ob, ptr)
                    let hook = @ptrv(vtable, fn(ptr)(), 3)
                    hook(ob)

                    @ptrv(item, u8, byte_state) = state_new
                }
                i++
            }

            block = @ptrv(block, ptr, 0)
        }

        let index = this.index
        let i : uint = 0
        let data = current + GP_DATA_OFFSET
        while i < index {
            let item = data + i * isize
            if @ptrv(item, u8, byte_state) == state_used {
                let ob = item + 8
                let vtable = @ptrv(ob, ptr)
                let hook = @ptrv(vtable, fn(ptr)(), 3)
                hook(ob)

                @ptrv(item, u8, byte_state) = state_new
            }
            i++
        }
    }

    fn clean_unmarked(age: u8) {
        // if this.pool_index == 0 {
        //     let c = this.blockc
        //     c.print(10)
        //     print("_\n")
        // }

        let current = this.block
        let block = this.first
        let isize = this.isize

        while block != null {
        // if this.pool_index == 0 {
        //     print("x")
        // }
            let b = block
            let count = @ptrv(b, uint, 1)
            if count > 0 {
                let used = @ptrv(b, uint, 2)
                // Loop items
                let i : uint = 0
                let data = b + GP_DATA_OFFSET

                while i < count {
                    let item = data + i * isize
                    let iage = @ptrv(item, u8, byte_age)
                    if iage != age && @ptrv(item, u8, byte_state) == state_solid {
                        if this.has_free_hook {
                            let ob = item + 8
                            let vtable = @ptrv(ob, ptr)
                            let hook = @ptrv(vtable, fn(ptr)(), 3)
                            hook(ob)
                        }
                        @ptrv(item, u8, byte_state) = state_new
                        @ptrv(item, u8, byte_age) = 0
                        @ptrv(item, u8, byte_shared_age) = 0
                        used--
                    }
                    i++
                }

                @ptrv(b, uint, 2) = used
                @ptrv(b, uint, 3) = used * 100 / count
            }

            block = @ptrv(b, ptr, 0) // next block
        }
    }

    // fn reset() {
    //     // Update usage percentage
    //     let current = this.block
    //     if current == null : return
    //     let first = this.first
    //     let block = first
    //     let prev = first
    //     while true {
    //         let b = block
    //         let count = @ptrv(b, uint, 1)
    //         let used = @ptrv(b, uint, 2)
    //         @ptrv(b, uint, 3) = used * 100 / count
    //         if b == current : break
    //         block = @ptrv(b, ptr, 0)
    //     }

    //     // Free unused blocks after current
    //     block = @ptrv(current, ptr, 0)
    //     prev = current
    //     while block != null {
    //         let b = block
    //         let used = @ptrv(b, uint, 2)
    //         let next = @ptrv(b, ptr, 0)

    //         if used == 0 {
    //             @ptrv(prev, ptr, 0) = next
    //             free(b)
    //             block = next
    //             this.blockc--
    //             continue
    //         }
    //         prev = b
    //         block = next
    //     }
    //     //
    //     this.set_block(this.first)
    // }
    fn reset() {
        let block = this.first
        let current = this.block

        let reached_current = false
        let last : ?ptr = null
        let first_empty_block : ?ptr = null
        let last_empty_block : ?ptr = null

        let t : uint = 0

        while block != null {
            let b = block
            let used = @ptrv(b, uint, 2)
            let next = @ptrv(b, ptr, 0)
            @ptrv(b, ?ptr, 0) = null // clear next
            t += @ptrv(b, uint, 1)
            //
            if used == 0 {
                if reached_current == false {
                    @ptrv(b, uint, 3) = 0
                    if isset(last_empty_block) {
                        @ptrv(last_empty_block, ptr, 0) = b
                        last_empty_block = b
                    } else {
                        first_empty_block = b
                        last_empty_block = b
                    }
                } else {
                    free(b)
                    this.blockc--
                }
            } else {
                // Update usage percent
                let count = @ptrv(b, uint, 1)
                @ptrv(b, uint, 3) = used * 100 / count
                //
                if isset(last) : @ptrv(last, ptr, 0) = b
                else : this.first = b
                last = b
            }
            if b == current : reached_current = true
            block = next
        }

        if isset(first_empty_block) {
            if isset(last)  {
                @ptrv(last, ptr, 0) = first_empty_block
            } else {
                this.first = first_empty_block
            }
        } else {
            if isset(last)  {
                @ptrv(last, ?ptr, 0) = null
            }
        }

        // t.print(10)
        // print("<")

        this.set_block(this.first)
        // this.count_new = false
    }
}
