
use io

value GP_DATA_OFFSET (sizeof(ptr) * 4)

global pools: @ignu(ptr)
global pool_count: uint

fn init_pools() {
    let list = alloc(150 * sizeof(ptr))
    pools = list
    let isize : uint = sizeof(ptr)
    let i : u8 = 0
    // 16 - 128
    while isize < 128 {
        isize += sizeof(ptr)
        @ptrv(list, ptr, i) = GcPool.init(isize, false, i)
        i++
        @ptrv(list, ptr, i) = GcPool.init(isize, true, i)
        i++
    }
    // 256 - max
    let pow : uint = 7
    let maxbits : uint = sizeof(ptr) * 8 - 24
    while pow < maxbits {
        let isize : uint = 2 << pow++
        @ptrv(list, ptr, i) = GcPool.init(isize, false, i)
        i++
        @ptrv(list, ptr, i) = GcPool.init(isize, true, i)
        i++
    }

    pool_count = i
    pools = list
}

cstruct GcPool {
    blockc: uint
    first: ptr
    block: ptr
    index: uint (0)
    isize: uint (0)
    pool_index: u8
    has_free_hook: bool

    static fn init(size: uint, has_free_hook: bool, pool_index: u8) SELF {
        let isize = size + 8
        let blockc : uint = 1
        let block = null @as ptr
        let res = SELF{
            blockc: blockc
            first: block
            block: block
            isize: isize
            pool_index: pool_index
            has_free_hook: has_free_hook
        }
        return res
    }

    static fn create_block(size: uint, isize: uint, pool_index: u8) ptr {
        if size > 248 : size = 248
        let b = alloc(size * isize + GP_DATA_OFFSET)
        // Settings
        @ptrv(b, ?ptr, 0) = null // next block
        @ptrv(b, uint, 1) = size // count
        @ptrv(b, uint, 2) = 0 // used
        @ptrv(b, uint, 3) = 0 // usage percent
        // Set indexes
        let data = b + GP_DATA_OFFSET
        let i : u8 = 0
        while i < size {
            let item : ptr = data + i * isize
            @ptrv(item, u64, 0) = 0 // clear data
            @ptrv(item, u8, 0) = state_new
            @ptrv(item, u8, 1) = 0
            @ptrv(item, u8, 2) = 0
            @ptrv(item, u8, 3) = pool_index
            @ptrv(item, u8, 4) = i
            i++
        }
        return b
    }

    fn get() ptr {
        // if mem_usage > 70 {
        //     gc()
        // }
        let pos = stack_pos
        let diff : uint = (pos.adr - pos.base) @as uint
        if diff < mem_min {
            mem_min = diff
        }
        if diff > mem_max {
            mem_max = diff
        }


        let isize = this.isize
        if this.block == null {
            this.block = SELF.create_block(this.blockc * 2, isize, this.pool_index)
            this.first = this.block
        }

        while true {
            let block = this.block
            if @ptrv(block, uint, 3) > 80 {
                this.set_next_block(block)
                continue
            }
            let index = this.index
            if index == @ptrv(block, uint, 1) {
                this.set_next_block(block)
                continue
            }
            this.index++
            let data = block + GP_DATA_OFFSET
            let item = data + index * isize
            if @ptrv(item, u8, byte_state) != state_new {
                continue
            }

            // if this.has_free_hook {
            //     @ptrv(item, u8, byte_state) = state_used
            // }

            // Increase mem usage
            mem_new += isize

            return (item + 8)
        }
        print("Failed to allocate memory")
        print("\n")
        exit(1)
    }

    fn set_next_block(block: ptr) {
        let next = @ptrv(block, ?ptr, 0)
        if isset(next) {
            this.set_block(next)
        } else {
            // Create new block
            let blockc = ++this.blockc
            let new = SELF.create_block(blockc * blockc, this.isize, this.pool_index)
            // Set next
            @ptrv(block, ptr, 0) = new
            this.set_block(new)
        }

        // Check mem usage
        update_usage()
        // if mem_usage > 70 {
        //     gc()
        // }
    }

    fn set_block(block: ptr) {
        this.block = block
        this.index = 0
    }

    fn swap_transfers() {
        if !this.has_free_hook : return
        return
        //
        let current = this.block
        let block = this.first
        let isize = this.isize
        if block == null : return

        while block != current {
            let b = block
            let count = @ptrv(b, uint, 1)
            // Loop items
            let i : uint = 0
            let data = b + GP_DATA_OFFSET
            while i < count {
                let item = data + i * isize
                if @ptrv(item, u8, byte_state) == state_used {
                    let ob = item + 8
                    let vtable = @ptrv(ob, ptr)
                    let hook = @ptrv(vtable, fn(ptr)(), 3)
                    hook(ob)

                    @ptrv(item, u8, byte_state) = state_new
                }
                i++
            }

            block = @ptrv(block, ptr, 0)
        }

        let index = this.index
        let i : uint = 0
        let data = current + GP_DATA_OFFSET
        while i < index {
            let item = data + i * isize
            if @ptrv(item, u8, byte_state) == state_used {
                let ob = item + 8
                let vtable = @ptrv(ob, ptr)
                let hook = @ptrv(vtable, fn(ptr)(), 3)
                hook(ob)

                @ptrv(item, u8, byte_state) = state_new
            }
            i++
        }
    }

    fn clean_unmarked(age: u8) {
        // if this.pool_index == 0 {
        //     let c = this.blockc
        //     c.print(10)
        //     print("_\n")
        // }

        let current = this.block
        let block = this.first
        let isize = this.isize

        while block != null {
        // if this.pool_index == 0 {
        //     print("x")
        // }
            let b = block
            let count = @ptrv(b, uint, 1)
            if count > 0 {
                let used = @ptrv(b, uint, 2)
                // Loop items
                let i : uint = 0
                let data = b + GP_DATA_OFFSET

                while i < count {
                    let item = data + i * isize
                    let iage = @ptrv(item, u8, byte_age)
                    if iage != age && @ptrv(item, u8, byte_state) == state_solid {
                        if this.has_free_hook {
                            let ob = item + 8
                            let vtable = @ptrv(ob, ptr)
                            let hook = @ptrv(vtable, fn(ptr)(), 3)
                            hook(ob)
                        }
                        @ptrv(item, u8, byte_state) = state_new
                        @ptrv(item, u8, byte_age) = 0
                        @ptrv(item, u8, byte_shared_age) = 0
                        used--
                    }
                    i++
                }

                @ptrv(b, uint, 2) = used
                @ptrv(b, uint, 3) = used * 100 / count
            }

            block = @ptrv(b, ptr, 0) // next block
        }
    }

    fn reset() {
        // Update usage percentage
        let current = this.block
        if current == null : return
        let first = this.first
        let block = first
        let prev = first
        while true {
            let b = block
            let count = @ptrv(b, uint, 1)
            let used = @ptrv(b, uint, 2)
            @ptrv(b, uint, 3) = used * 100 / count
            if b == current : break
            block = @ptrv(b, ptr, 0)
        }

        // Free unused blocks after current
        block = @ptrv(current, ptr, 0)
        prev = current
        while block != null {
            let b = block
            let used = @ptrv(b, uint, 2)
            let next = @ptrv(b, ptr, 0)

            if used == 0 {
                @ptrv(prev, ptr, 0) = next
                free(b)
                block = next
                this.blockc--
                continue
            }
            prev = b
            block = next
        }
        //
        this.set_block(this.first)
    }
}
