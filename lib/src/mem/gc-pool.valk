
use io

value GP_DATA_OFFSET (sizeof(ptr) * 4)

global pools: @ignu(ptr)
global pool_count: uint

fn init_pools() {
    let list = alloc(150 * sizeof(ptr))
    pools = list
    let isize : uint = sizeof(ptr)
    let i : u8 = 0
    // 16 - 128
    while isize < 128 {
        isize += sizeof(ptr)
        @ptrv(list, ptr, i) = GcPool.init(isize, false, i)
        i++
        @ptrv(list, ptr, i) = GcPool.init(isize, true, i)
        i++
    }
    // 256 - max
    let pow : uint = 7
    let maxbits : uint = sizeof(ptr) * 8 - 24
    while pow < maxbits {
        let isize : uint = 2 << pow++
        @ptrv(list, ptr, i) = GcPool.init(isize, false, i)
        i++
        @ptrv(list, ptr, i) = GcPool.init(isize, true, i)
        i++
    }

    pool_count = i
    pools = list
}

cstruct GcPool {
    blockc: uint (0) // blocks count
    blocku: uint (0) // blocks usage
    first: ptr (null @as ptr)
    block: ptr (null @as ptr)
    index: uint (0)
    isize: uint (0)
    pool_index: u8
    has_free_hook: bool
    count_new: bool (false)

    static fn init(size: uint, has_free_hook: bool, pool_index: u8) SELF {
        let isize = size + 8
        let res = SELF{
            isize: isize
            pool_index: pool_index
            has_free_hook: has_free_hook
        }
        return res
    }

    static fn create_block(size: uint, isize: uint, pool_index: u8) ptr {
        if size > 248 : size = 248
        let b = alloc(size * isize + GP_DATA_OFFSET)
        // Settings
        @ptrv(b, ?ptr, 0) = null // next block
        @ptrv(b, uint, 1) = size // count
        @ptrv(b, uint, 2) = 0 // used
        @ptrv(b, uint, 3) = 0 // usage percent
        // Set indexes
        let data = b + GP_DATA_OFFSET
        let i : u8 = 0
        while i < size {
            let item : ptr = data + i * isize
            @ptrv(item, u64, 0) = 0 // clear data
            @ptrv(item, u8, 0) = state_new
            @ptrv(item, u8, 3) = i
            i++
        }
        return b
    }

    fn get() ptr {

        let isize = this.isize
        if this.block == null {
            this.blockc++
            this.blocku++
            this.block = SELF.create_block(this.blockc * 2, isize, this.pool_index)
            this.first = this.block
            this.count_new = true
        }

        // let pos = stack_pos
        // let stack_size : uint = (pos.adr - pos.base) @as uint
        // if stack_size < mem_min {
        //     mem_min = stack_size
        // }
        // if stack_size > mem_max {
        //     mem_max = stack_size
        // }
        // let block_usage = this.blocku * 100 / this.blockc
        // if block_usage > 95 : update_usage()

        while true {
            let block = this.block
            // let slots = @ptrv(block, uint, 1)
            // let data = block + GP_DATA_OFFSET

            // // Find open slot
            // let index = this.index
            // let found = false
            // while index < slots {
            //     let item = data + index * isize
            //     if @ptrv(item, u8, byte_state) == state_new {
            //         break
            //     }
            //     index++
            // }
            // if index == slots {
            //     this.set_next_block(block)
            //     continue
            // }

            // // Found open slot
            // this.index = index + 1
            // let item = data + index * isize

            let index = this.index
            if index == @ptrv(block, uint, 1) {
                this.set_next_block(block)
                continue
            }
            this.index++
            let data = block + GP_DATA_OFFSET
            let item = data + index * isize
            if @ptrv(item, u8, byte_state) != state_new {
                continue
            }

            if this.has_free_hook {
                @ptrv(item, u8, byte_state) = state_used
            }

            // Increase mem usage
            if this.count_new {
                mem_new += isize
                mem_usage = mem_new / (mem_trigger / 100)
            }

            @ptrv(item, u32, 1) = 0

            return (item + 8)
        }
        print("Failed to allocate memory")
        print("\n")
        exit(1)
    }

    fn set_next_block(block: ptr) {
        while true {
            this.blocku++

            let next = @ptrv(block, ?ptr, 0)
            if isset(next) {
                if @ptrv(next, uint, 3) > 90 {
                    block = next
                    continue
                }
                this.set_block(next)
            } else {
                // Create new block
                let blockc = ++this.blockc
                let new = SELF.create_block(blockc * blockc, this.isize, this.pool_index)
                // Set next
                @ptrv(block, ptr, 0) = new
                this.set_block(new)
                this.count_new = true
            }
            break
        }
    }

    fn set_block(block: ptr) {
        this.block = block
        this.index = 0
    }

    fn swap_transfers() {
        if !this.has_free_hook : return
        return
        //
        let current = this.block
        let block = this.first
        let isize = this.isize
        if block == null : return

        while block != current {
            let b = block
            let count = @ptrv(b, uint, 1)
            // Loop items
            let i : uint = 0
            let data = b + GP_DATA_OFFSET
            while i < count {
                let item = data + i * isize
                if @ptrv(item, u8, byte_state) == state_used {
                    let ob = item + 8
                    let vtable = @ptrv(ob, ptr)
                    let hook = @ptrv(vtable, fn(ptr)(), 3)
                    hook(ob)

                    @ptrv(item, u8, byte_state) = state_new
                }
                i++
            }

            block = @ptrv(block, ptr, 0)
        }

        let index = this.index
        let i : uint = 0
        let data = current + GP_DATA_OFFSET
        while i < index {
            let item = data + i * isize
            if @ptrv(item, u8, byte_state) == state_used {
                let ob = item + 8
                let vtable = @ptrv(ob, ptr)
                let hook = @ptrv(vtable, fn(ptr)(), 3)
                hook(ob)

                @ptrv(item, u8, byte_state) = state_new
            }
            i++
        }
    }

    fn clean_unmarked(age: u8) {

        let current = this.block
        let block = this.first
        let isize = this.isize

        while block != null {
            let b = block
            let count = @ptrv(b, uint, 1)
            if count > 0 {
                // Loop items
                let i : uint = 0
                let data = b + GP_DATA_OFFSET
                let removed : uint = 0

                while i < count {
                    let item = data + i * isize
                    let iage = @ptrv(item, u8, byte_age)
                    if iage != age && @ptrv(item, u8, byte_state) == state_solid {
                        // if this.has_free_hook {
                            // let ob = item + 8
                            // let vtable = @ptrv(ob, ptr)
                            // let hook = @ptrv(vtable, fn(ptr)(), 3)
                            // hook(ob)
                        // }
                        @ptrv(item, u8, byte_state) = state_new
                        @ptrv(item, u8, byte_age) = 0
                        @ptrv(item, u8, byte_shared_age) = 0
                        removed++

                    }
                    i++
                }

                mem_active -= removed * isize
                @ptrv(b, uint, 2) -= removed
                @ptrv(b, uint, 3) = @ptrv(b, uint, 2) * 100 / count
            }

            block = @ptrv(b, ptr, 0) // next block
        }
    }

    fn reset() {
        // Update usage percentage
        let block = this.first
        let current = this.block
        let reached_current = false
        let last : ?ptr = null
        let first_empty_block : ?ptr = null
        let last_empty_block : ?ptr = null
        while block != null {
            let b = block
            let used = @ptrv(b, uint, 2)
            let next = @ptrv(b, ptr, 0)
            //
            if used == 0 {
                if reached_current == false {
                    @ptrv(b, uint, 3) = 0
                    if isset(last_empty_block) {
                        @ptrv(last_empty_block, ptr, 0) = b
                        last_empty_block = b
                    } else {
                        first_empty_block = b
                        last_empty_block = b
                    }
                } else {
                    // Free block
                    if isset(last) {
                        @ptrv(last, ptr, 0) = next
                    } else {
                        this.first = next
                    }
                    free(b)
                    this.blockc--
                }
            } else {
                // Update usage percent
                let count = @ptrv(b, uint, 1)
                @ptrv(b, uint, 3) = used * 100 / count
                //
                last = b
            }
            if b == current : reached_current = true
            block = next
        }

        if isset(first_empty_block) {
            if isset(last)  {
                @ptrv(last, ptr, 0) = first_empty_block
            } else {
                this.first = first_empty_block
            }
        }

        this.set_block(this.first)
        this.blocku = this.first == null ? 0 : 1
        this.count_new = false
    }
}
