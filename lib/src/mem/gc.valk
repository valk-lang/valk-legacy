
use io
use os

fn gc_bump_alloc(size: uint) ptr {
    return stack.bump.alloc(size)
}
fn gc() {
    stack.gc()
}
fn force_gc() {
    stack.force_full = true
    stack.gc()
}

fn update_usage() {
    // 
    let pos = stack_pos
    let stack_size : uint = (pos.adr - pos.base) @as uint
    stack_size -= mem_min
    //
    if mem_max < mem_min + 128 {
        mem_max = mem_min + 128
    }
    let max_stack_size = mem_max - mem_min

    // Calculate mem usage
    mem_usage = mem_new / (mem_trigger / 100)

    // Scale mem_usage trigger point based on stack position
    // 12 * (number between: 1 - 21)
    let trigger : uint = 12 * (stack_size * 20 / max_stack_size + 1)

    if mem_usage > trigger {
        gc()
    // } else {
        // mem_gc_loop = mem_usage > 10
    }

    // Update min/max
    mem_min += sizeof(ptr)
    mem_max -= sizeof(ptr)
}

fn gc_transfer(item: ptr) {

    let vtable = @ptrv(item, ptr, 0)
    let hook = @ptrv(vtable, fn(ptr)(), vt_hook_transfer)
    hook(item)

    // if @ptrv(item, u8, byte_state_rel) > state_transfer : return
    // @ptrv(item, u8, byte_state_rel) = state_solid

    // let pool_index = @ptrv(item, u8, byte_pool_index_rel)
    // let pool = @ptrv(pools, GcPool, pool_index)
    // let size = pool.isize

    // mem_active += size

    // let block_index = @ptrv(item, u8, byte_block_index_rel)
    // let block_start = item - 8 - block_index * size
    // @ptrv(block_start, uint, -2)++ // Increase used items count

    // // Hook
    // let vtable = @ptrv(item, ptr, 0)
    // let hook = @ptrv(vtable, ?fn(ptr)(), vt_hook_transfer)
    // if isset(hook) : hook(item)

    // let propc = @ptrv(item, u8, byte_gc_prop_count_rel) + 2
    // while propc-- > 2 {
    //     let sub = @ptrv(item, ptr, propc)
    //     if sub == null : continue
    //     @ptrv(sub, uint, 1)++
    //     gc_transfer(sub)
    // }
}

fn gc_free(item: ptr) {

    let vtable = @ptrv(item, ptr, 0)
    let hook = @ptrv(vtable, fn(ptr)(), vt_hook_free)
    hook(item)

    // if @ptrv(item, u8, byte_state_rel) != state_solid : return
    // @ptrv(item, u8, byte_state_rel) = state_new
    // @ptrv(item, u8, byte_age_rel) = 0
    // @ptrv(item, u8, byte_shared_age_rel) = 0

    // let pool_index = @ptrv(item, u8, byte_pool_index_rel)
    // let pool = @ptrv(pools, GcPool, pool_index)
    // let size = pool.isize

    // mem_active -= size

    // let block_index = @ptrv(item, u8, byte_block_index_rel)
    // let block_start = item - 8 - block_index * size
    // @ptrv(block_start, uint, -2)-- // Decrease used items count

    // // Hook
    // let vtable = @ptrv(item, ptr, 0)
    // let hook = @ptrv(vtable, ?fn(ptr)(), vt_hook_free)
    // if isset(hook) : hook(item)

    // let propc = @ptrv(item, u8, byte_gc_prop_count_rel) + 2
    // while propc-- > 2 {
    //     let sub = @ptrv(item, ptr, propc)
    //     if sub == null : continue
    //     // if @ptrv(sub, u8, byte_state_rel) != state_solid : continue
    //     let rc = atomic(@ptrv(sub, uint, 1) - 1)
    //     if rc == 1 {
    //         gc_free(sub)
    //     }
    // }
}

fn gc_mark(item: ptr, age: u8) {

    let vtable = @ptrv(item, ptr, 0)
    let hook = @ptrv(vtable, fn(ptr, u8)(), vt_hook_mark)
    hook(item, age)

    // if @ptrv(item, u8, byte_state_rel) > state_const : return
    // if @ptrv(item, u8, byte_age_rel) == age : return
    // @ptrv(item, u8, byte_age_rel) = age

    // let pool_index = @ptrv(item, u8, byte_pool_index_rel)
    // let pool = @ptrv(pools, GcPool, pool_index)
    // let size = pool.isize

    // mem_marked += size

    // // Hook
    // let vtable = @ptrv(item, ptr, 0)
    // let hook = @ptrv(vtable, ?fn(ptr)(), vt_hook_mark)
    // if isset(hook) : hook(item)

    // let propc = @ptrv(item, u8, byte_gc_prop_count_rel) + 2
    // while propc-- > 2 {
    //     let sub = @ptrv(item, ptr, propc)
    //     if sub == null : continue
    //     gc_mark(sub, age)
    // }
}

fn gc_mark_shared(item: ptr, age: u8) {

    let vtable = @ptrv(item, ptr, 0)
    let hook = @ptrv(vtable, fn(ptr, u8)(), vt_hook_mark_shared)
    hook(item, age)

    // if @ptrv(item, u8, byte_state_rel) > state_const : return
    // if @ptrv(item, u8, byte_shared_age_rel) == age : return
    // @ptrv(item, u8, byte_shared_age_rel) = age

    // // Hook
    // let vtable = @ptrv(item, ptr, 0)
    // let hook = @ptrv(vtable, ?fn(ptr)(), vt_hook_mark_shared)
    // if isset(hook) : hook(item)

    // let propc = @ptrv(item, u8, byte_gc_prop_count_rel) + 2
    // while propc-- > 2 {
    //     let sub = @ptrv(item, ptr, propc)
    //     if sub == null : continue
    //     gc_mark_shared(sub, age)
    // }
}

fn gc_share(item: ptr) {

    let vtable = @ptrv(item, ptr, 0)
    let hook = @ptrv(vtable, fn(ptr)(), vt_hook_share)
    hook(item)

    // if @ptrv(item, u8, byte_state_rel) > state_solid : return

    // let state = @ptrv(item, u8, byte_state_rel)
    // if state < state_solid {
    //     let pool_index = @ptrv(item, u8, byte_pool_index)
    //     let pool = @ptrv(pools, GcPool, pool_index)
    //     let size = pool.isize

    //     // mem_transfered += size

    //     let block_index = @ptrv(item, u8, byte_block_index_rel)
    //     let block_start = item - 8 - block_index * size
    //     @ptrv(block_start, uint, -2)++ // Increase used items count
    // } else {
    //     let pool_index = @ptrv(item, u8, byte_pool_index)
    //     let pool = @ptrv(pools, GcPool, pool_index)
    //     let size = pool.isize

    //     mem_active -= size
    // }

    // @ptrv(item, u8, byte_state_rel) = state_shared
    // @ptrv(item, u8, byte_shared_age_rel) = shared_age
    // stack.add_shared(item)

    // // Hook
    // let vtable = @ptrv(item, ptr, 0)
    // let hook = @ptrv(vtable, ?fn(ptr)(), vt_hook_share)
    // if isset(hook) : hook(item)

    // let propc = @ptrv(item, u8, byte_gc_prop_count_rel) + 2
    // while propc-- > 2 {
    //     let sub = @ptrv(item, ptr, propc)
    //     if sub == null : continue
    //     gc_share(sub)
    // }
}

fn pools_swap_transfers() {
    let alcs = pools
    let count = pool_count
    let i : uint = 0
    while i < count {
        let pool = @ptrv(alcs, GcPool, i++)
        if pool.first == null : continue
        pool.swap_transfers()
    }
}

fn pools_clean_unmarked(age: u8) {
    let alcs = pools
    let count = pool_count
    let i : uint = 0
    while i < count {
        let pool = @ptrv(alcs, GcPool, i++)
        if pool.first == null : continue
        pool.clean_unmarked(age)
    }
    // gc_alloc_clean_unmarked(age)
}

fn pools_reset() {
    let alcs = pools
    let count = pool_count
    let i : uint = 0
    while i < count {
        let pool = @ptrv(alcs, GcPool, i++)
        if pool.first == null : continue
        pool.reset()
    }
    // gc_alloc_reset()
}
