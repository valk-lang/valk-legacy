
use io
use os

fn gc_bump_alloc(size: uint) ptr {
    return stack.bump.alloc(size)
}
fn gc() {
    stack.gc()
}
fn force_gc() {
    stack.force_full = true
    stack.gc()
}

fn update_usage() {
    // Calculate mem usage
    if mem_new > mem_trigger : gc()
    // mem_usage = mem_new * 100 / mem_trigger
    // if mem_usage > 20 {
    //     gc()
    // }
}

fn gc_mark(item: ptr, color: u16) {

    let item_color = @ptrv(item, u16, byte_color_rel)
    if @ptrv(colors.valid, u8, item_color) == color_valid { 
        return
    }

    //
    @ptrv(item, u16, byte_color_rel) = color

    if item_color == 0 {
        let pool_index = @ptrv(item, u8, byte_pool_index_rel)
        let pool = @ptrv(pools, GcPool, pool_index)
        let size = pool.isize

        mem_marked += size

        let block_index = @ptrv(item, u8, byte_block_index_rel)
        let block_start = item - 8 - block_index * size
        @ptrv(block_start, uint, -2)++ // Increase used items count
    }

    let propc = @ptrv(item, u8, byte_gc_prop_count_rel)
    if propc > 0 {
        let added = false
        let count = propc
        let i = 0
        let has_vtable = @ptrv(item, bool, byte_has_vtable_rel)
        if has_vtable : i++
        while count-- > 0 {
            let sub = @ptrv(item, ptr, i++)
            if sub == null : continue
            gc_mark(sub, color)
            let sub_color = @ptrv(item, u16, byte_color_rel)
            if sub_color != color && !added {
                // Add to remark
                remark.add(item)
                added = true
            }
        }
    }
}

fn gc_demark(item: ptr, color: u16) {

    if @ptrv(item, u16, byte_color_rel) != color : return
    @ptrv(item, u16, byte_color_rel) = color_blank

    let pool_index = @ptrv(item, u8, byte_pool_index_rel)
    let pool = @ptrv(pools, GcPool, pool_index)
    let size = pool.isize

    mem_marked -= size

    let block_index = @ptrv(item, u8, byte_block_index_rel)
    let block_start = item - 8 - block_index * size
    @ptrv(block_start, uint, -2)-- // Increase used items count

    let propc = @ptrv(item, u8, byte_gc_prop_count_rel)
    if propc > 0 {
        let i = 0
        let has_vtable = @ptrv(item, bool, byte_has_vtable_rel)
        if has_vtable : i++
        while propc-- > 0 {
            let sub = @ptrv(item, ptr, i++)
            if sub == null : continue
            gc_demark(sub, color)
        }
    }
}

fn gc_unlink_item(item: ptr, color: u16) {
    if @ptrv(item, u16, byte_color_rel) != color : return
    @ptrv(item, u16, byte_color_rel) = color_unlink

    let propc = @ptrv(item, u8, byte_gc_prop_count_rel)
    if propc > 0 {
        let i = 0
        let has_vtable = @ptrv(item, bool, byte_has_vtable_rel)
        if has_vtable : i++
        while propc-- > 0 {
            let sub = @ptrv(item, ptr, i++)
            if sub == null : continue
            gc_unlink_item(sub, color)
        }
    }
}

fn gc_mark_shared(item: ptr, age: u8) {

    if @ptrv(item, u16, byte_color_rel) > state_const : return
    if @ptrv(item, u8, byte_shared_age_rel) == age : return
    @ptrv(item, u8, byte_shared_age_rel) = age

    let propc = @ptrv(item, u8, byte_gc_prop_count_rel)
    if propc > 0 {
        let has_vtable = @ptrv(item, bool, byte_has_vtable_rel)
        let i = 0
        if has_vtable {
            i++
            // Hook
            let vtable = @ptrv(item, ptr, 0)
            let hook = @ptrv(vtable, ?fn(ptr, u8)(), vt_hook_mark_shared)
            if isset(hook) : hook(item, age)
        }
        while propc-- > 0 {
            let sub = @ptrv(item, ptr, i++)
            if sub == null : continue
            gc_mark_shared(sub, age)
        }
    }
}

fn gc_share(item: ptr) {

    if @ptrv(item, u8, byte_state_rel) > state_solid : return

    let state = @ptrv(item, u8, byte_state_rel)
    if state < state_solid {
        let pool_index = @ptrv(item, u8, byte_pool_index)
        let pool = @ptrv(pools, GcPool, pool_index)
        let size = pool.isize

        mem_transfered += size

        let block_index = @ptrv(item, u8, byte_block_index_rel)
        let block_start = item - 8 - block_index * size
        @ptrv(block_start, uint, -2)++ // Increase used items count
    }

    @ptrv(item, u8, byte_state_rel) = state_shared
    @ptrv(item, u8, byte_shared_age_rel) = shared_age
    stack.add_shared(item)

    let propc = @ptrv(item, u8, byte_gc_prop_count_rel)
    if propc > 0 {
        let has_vtable = @ptrv(item, bool, byte_has_vtable_rel)
        let i = 0
        if has_vtable {
            i++
            // Hook
            let vtable = @ptrv(item, ptr, 0)
            let hook = @ptrv(vtable, ?fn(ptr)(), vt_hook_share)
            if isset(hook) : hook(item)
        }
        while propc-- > 0 {
            let sub = @ptrv(item, ptr, i++)
            if sub == null : return
            gc_share(sub)
        }
    }
}

fn pools_swap_transfers() {
    let alcs = pools
    let count = pool_count
    let i : uint = 0
    while i < count {
        let pool = @ptrv(alcs, GcPool, i++)
        pool.swap_transfers()
    }
}

fn pools_clean_unmarked(age: u8) {
    let alcs = pools
    let count = pool_count
    let i : uint = 0
    while i < count {
        let pool = @ptrv(alcs, GcPool, i++)
        pool.clean_unmarked(age)
    }
    gc_alloc_clean_unmarked(age)
}

fn pools_reset() {
    let alcs = pools
    let count = pool_count
    let i : uint = 0
    while i < count {
        let pool = @ptrv(alcs, GcPool, i++)
        pool.reset()
    }
    gc_alloc_reset()
}
